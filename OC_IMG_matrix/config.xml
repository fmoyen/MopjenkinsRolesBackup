<?xml version='1.1' encoding='UTF-8'?>
<matrix-project plugin="matrix-project@1.14">
  <actions/>
  <description>Builds bitstreams with different configurations and tests images on real HW if possible.&#xd;
In case of problems: please contact fabrice_moyen@fr.ibm.com or alexandre.castellane@fr.ibm.com&#xd;
&#xd;
Vivado version used : tests on going for 2019.1 (issue with lsf / RH7)&#xd;
AC 28 fev 2020 : changed default to 2019.2&#xd;
AC late Nov 2020 : changed default to 2020.1 (simulations still in 2019.2)&#xd;
&#xd;
Main Issues : &#xd;
OC-BW250SOC : does not program from jenkins images, and doesn&apos;t reset/reload properly on pavilly &#xd;
&#xd;
OC-AD9H7:&#xd;
   - hls_hbm_memcopy_1024 ) SOLVED !!!  timing were failing for HBM (even with default 12)&#xd;
   - oc-flash not operational (for OC-AD9H7 only) =&gt; NO HARDWARE TEST ON OC-AD9H7&#xd;
   - hdl_ex fails on 9V3 ???&#xd;
&#xd;
If required TEMPORARILY CHANGE TO fleon&apos;s : git  https://github.com/fleon-psi/oc-accel.git&#xd;
instead of : git@github.com:/OpenCAPI/oc-accel.git </description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <hudson.plugins.jira.JiraProjectProperty plugin="jira@3.0.11"/>
    <com.coravy.hudson.plugins.github.GithubProjectProperty plugin="github@1.29.5">
      <projectUrl>https://github.com/OpenCAPI/oc-accel/</projectUrl>
      <displayName></displayName>
    </com.coravy.hudson.plugins.github.GithubProjectProperty>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>BRANCH</name>
          <description>Choose the branch for https://github.com/OpenCAPI/oc-accel you want to test.</description>
          <defaultValue>master</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>OCUTILS_URL</name>
          <description>URL for oc-utils github project (you may change this only if you want to test a specific fork repository)</description>
          <defaultValue>https://github.com/OpenCAPI/oc-utils</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>OCUTILS_BRANCH</name>
          <description>Choose the branch for $OCUTILS_URL (typically https://github.com/OpenCAPI/oc-utils) you want to test. Please do not use wildcards!!</description>
          <defaultValue>master</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>OCSE_BRANCH</name>
          <description>Choose the branch for https://github.com/OpenCAPI/ocse you want to test.
(OpenCapi Simulation Engine)</description>
          <defaultValue>master</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.plugins.matrix__configuration__parameter.MatrixCombinationsParameterDefinition plugin="matrix-combinations-parameter@1.3.1">
          <name>MatrixFilter</name>
          <description>The existence of a Matrix Combinations Parameter (whatever its name is) makes the Matrix Combination Plugin run.</description>
          <shortcutList>
            <hudson.plugins.matrix__configuration__parameter.shortcut.ResultShortcut>
              <name>Successful</name>
              <exact>false</exact>
              <resultsToCheck>
                <string>SUCCESS</string>
              </resultsToCheck>
            </hudson.plugins.matrix__configuration__parameter.shortcut.ResultShortcut>
            <hudson.plugins.matrix__configuration__parameter.shortcut.ResultShortcut>
              <name>Failed</name>
              <exact>false</exact>
              <resultsToCheck>
                <string>FAILURE</string>
              </resultsToCheck>
            </hudson.plugins.matrix__configuration__parameter.shortcut.ResultShortcut>
            <hudson.plugins.matrix__configuration__parameter.shortcut.MatrixCombinationsShortcut_-All/>
            <hudson.plugins.matrix__configuration__parameter.shortcut.MatrixCombinationsShortcut_-None/>
          </shortcutList>
        </hudson.plugins.matrix__configuration__parameter.MatrixCombinationsParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>VIVADO_GLOBAL</name>
          <description>Choose the Vivado version to use
This parameter overseedes all VIVADO_XXX parameters below
If -- then VIVADO_XXX parameters below are taken into account</description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>2020.1</string>
              <string>2019.2</string>
              <string>--</string>
              <string>2019.1</string>
              <string>2018.3</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>VIVADO_OC_AD9V3</name>
          <description></description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>2020.1</string>
              <string>2019.2</string>
              <string>2019.1</string>
              <string>2018.3</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>VIVADO_OC_AD9H3</name>
          <description></description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>2020.1</string>
              <string>2019.2</string>
              <string>2019.1</string>
              <string>2018.3</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>VIVADO_OC_AD9H335</name>
          <description></description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>2020.1</string>
              <string>2019.2</string>
              <string>2019.1</string>
              <string>2018.3</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>VIVADO_OC_AD9H7</name>
          <description></description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>2020.1</string>
              <string>2019.2</string>
              <string>2019.1</string>
              <string>2018.3</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>VIVADO_OC_BW250SOC</name>
          <description></description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>2020.1</string>
              <string>2019.2</string>
              <string>2019.1</string>
              <string>2018.3</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.ChoiceParameterDefinition>
          <name>TIMING_LABLIMIT_CHOICE</name>
          <description>Choose the TIMING_LABLIMIT parameter. If timing is higher than your choice when doing a make image, the run will failed.</description>
          <choices class="java.util.Arrays$ArrayList">
            <a class="string-array">
              <string>-300</string>
              <string>-600</string>
              <string>-1000</string>
            </a>
          </choices>
        </hudson.model.ChoiceParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <name>LSF_CLUSTER</name>
          <description>NOT YET AVAILABLE !!!
Decide whether or not to use the Boeblingen LSF cluster to build images.</description>
          <defaultValue>false</defaultValue>
        </hudson.model.BooleanParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <name>TEST_ON_HW</name>
          <description>Enable/disable testing on HW
(HDL_Example not running)
</description>
          <defaultValue>true</defaultValue>
        </hudson.model.BooleanParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>NO_TEST_CARDS</name>
          <description>The list of cards we do NOT want to HW test for different reasons (please see README for default reasons) </description>
          <defaultValue>OC-AD9H7 OC-AD9H335</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>mopBoxes</name>
          <description>List of Montpellier systems available for testing :
  - orpington: AC922 8335-GTH with one OC-AD9V3 (eventually C2 capable)
  - pavilly     : IC922 9183-22X with one OC-AD9V3 (eventually C2 capable), OC-AD9V2, OC-AD9H7 (not flash), OC-BW250SOC
(it needs to define capimop user with authorized_keys)</description>
          <defaultValue>orpington pavilly</defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>austinBoxes</name>
          <description>List of Austin systems available for testing :
(Assuming no VPN or jump server is needed to access Austin servers, 9.X.X.X addresses)
(it needs to define capimop user with authorized_keys)</description>
          <defaultValue></defaultValue>
          <trim>false</trim>
        </hudson.model.StringParameterDefinition>
        <hudson.model.BooleanParameterDefinition>
          <name>CHECKUSER</name>
          <description>Check if users are connected at working hours</description>
          <defaultValue>false</defaultValue>
        </hudson.model.BooleanParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
    <hudson.plugins.throttleconcurrents.ThrottleJobProperty plugin="throttle-concurrents@2.0.1">
      <maxConcurrentPerNode>1</maxConcurrentPerNode>
      <maxConcurrentTotal>10</maxConcurrentTotal>
      <categories class="java.util.concurrent.CopyOnWriteArrayList"/>
      <throttleEnabled>true</throttleEnabled>
      <throttleOption>category</throttleOption>
      <limitOneJobWithMatchingParams>true</limitOneJobWithMatchingParams>
      <matrixOptions>
        <throttleMatrixBuilds>false</throttleMatrixBuilds>
        <throttleMatrixConfigurations>true</throttleMatrixConfigurations>
      </matrixOptions>
      <paramsToUseForLimit></paramsToUseForLimit>
    </hudson.plugins.throttleconcurrents.ThrottleJobProperty>
  </properties>
  <scm class="hudson.plugins.git.GitSCM" plugin="git@4.0.0">
    <configVersion>2</configVersion>
    <userRemoteConfigs>
      <hudson.plugins.git.UserRemoteConfig>
        <url>git@github.com:/OpenCAPI/oc-accel.git</url>
      </hudson.plugins.git.UserRemoteConfig>
    </userRemoteConfigs>
    <branches>
      <hudson.plugins.git.BranchSpec>
        <name>${BRANCH}</name>
      </hudson.plugins.git.BranchSpec>
    </branches>
    <doGenerateSubmoduleConfigurations>false</doGenerateSubmoduleConfigurations>
    <submoduleCfg class="list"/>
    <extensions>
      <hudson.plugins.git.extensions.impl.RelativeTargetDirectory>
        <relativeTargetDir>oc-accel</relativeTargetDir>
      </hudson.plugins.git.extensions.impl.RelativeTargetDirectory>
      <hudson.plugins.git.extensions.impl.SubmoduleOption>
        <disableSubmodules>false</disableSubmodules>
        <recursiveSubmodules>true</recursiveSubmodules>
        <trackingSubmodules>false</trackingSubmodules>
        <reference></reference>
        <parentCredentials>false</parentCredentials>
        <shallow>false</shallow>
      </hudson.plugins.git.extensions.impl.SubmoduleOption>
    </extensions>
  </scm>
  <assignedNode>X86_UBUNTU</assignedNode>
  <canRoam>false</canRoam>
  <disabled>false</disabled>
  <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
  <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
  <triggers>
    <hudson.triggers.SCMTrigger>
      <spec>H 0-8/1 * * *
H 22-23/1 * * *</spec>
      <ignorePostCommitHooks>false</ignorePostCommitHooks>
    </hudson.triggers.SCMTrigger>
  </triggers>
  <concurrentBuild>true</concurrentBuild>
  <axes>
    <hudson.matrix.TextAxis>
      <name>ACT</name>
      <values>
        <string>hdl_example</string>
        <string>hdl_single_engine</string>
        <string>hls_helloworld_512</string>
        <string>hls_helloworld_1024</string>
        <string>hls_memcopy_512</string>
        <string>hls_memcopy_1024</string>
        <string>hls_hbm_memcopy_1024</string>
        <string>hls_image_filter</string>
        <string>hls_decimal_mult</string>
        <string>hls_udp_512</string>
        <string>test</string>
      </values>
    </hudson.matrix.TextAxis>
    <hudson.matrix.TextAxis>
      <name>CRD_CL</name>
      <values>
        <string>OC-AD9V3_nCL</string>
        <string>OC-AD9H3_nCL</string>
        <string>OC-AD9H335_nCL</string>
        <string>OC-AD9H7_nCL</string>
        <string>OC-BW250SOC_nCL</string>
      </values>
    </hudson.matrix.TextAxis>
    <hudson.matrix.LabelAxis>
      <name>label</name>
      <values>
        <string>X86_UBUNTU</string>
      </values>
    </hudson.matrix.LabelAxis>
  </axes>
  <combinationFilter> (ACT==&quot;test&quot; &amp;&amp; CRD_CL==&quot;OC-AD9V3_nCL&quot;)    ||   (    ACT!=&quot;test&quot; &amp;&amp;  (  (CRD_CL=~&quot;OC-AD9H&quot; &amp;&amp; !(ACT=~&quot;hls_memcopy_&quot;) )      ||    ( (CRD_CL=~&quot;OC-AD9V3&quot; || CRD_CL=~&quot;OC-BW250SOC&quot; ) &amp;&amp; !(ACT=~&quot;hls_hbm_memcopy_&quot;) &amp;&amp; !(ACT=~&quot;hls_udp&quot;) )        )       )</combinationFilter>
  <builders>
    <hudson.tasks.Shell>
      <command>#!/bin/bash
set +x                           # reduce Jenkins output

echo
echo &quot;****************************************************************************************&quot;
echo &quot;BUILD START (`date`)&quot;
echo &quot;****************************************************************************************&quot;
echo &quot;EXECUTING OpenCAPI IMG FIRST SHELL FROM MOPJENKINS ...&quot;
echo &quot;****************************************************************************************&quot;
echo &quot;Hostname: `hostname`&quot;; echo &quot;ID: `id`&quot;
echo &quot;Working dir is : $PWD&quot;
echo


#==============================================================================================
# Variables

&gt; export_props.properties
NAME=$(echo $GIT_BRANCH| cut -d&apos;/&apos; -f 2 |tr &apos;[:upper:]&apos; &apos;[:lower:]&apos;) # remove origin/ from branch and translate to lowercase
PREFIX=$(echo $NAME| cut -d&apos;_&apos; -f 1)    # chars up to first &apos;_&apos; identify need for test
ACTION_TYPE=$(echo $ACT| cut -d&apos;_&apos; -f 1 |tr &apos;[:lower:]&apos; &apos;[:upper:]&apos;) # get ACTION_TYPE (hls, hld) and translate to uppercase
CRD=$(echo $CRD_CL| cut -d&apos;_&apos; -f 1)    # chars up to  first &apos;_&apos; identify card
CRDSuffix=$(echo $CRD | cut -d&apos;-&apos; -f 2)
CL=$(echo $CRD_CL| cut -d&apos;_&apos; -f 2)     # chars behind first &apos;_&apos; identify Cloud build

echo &quot;Build with Card=$CRD Action=$ACT Action_type=$ACTION_TYPE CLOUD_build=$CL branch_selected=$BRANCH git_branch=$NAME prefix=$PREFIX LSFCluster=$LSF_CLUSTER test_on_hw=$TEST_ON_HW&quot;

EmailDestinationList=( fabrice_moyen@fr.ibm.com )
EmailOrNotEmail=0 # 0 means do not send emails; 1 means send email

HWUser=&quot;capimop&quot;

# Example: RootJobName= SNAP_IMG_CAPI2_matrix
RootJobName=`echo $JOB_NAME | awk -F&quot;/&quot; &apos;{print $1}&apos;` # $JOB_NAME-&gt; Jenkins global variable

# Example: LocalWorkspace= /var/jenkins/workspace/SNAP_IMG_CAPI2_matrix@2/master/ACT/hdl_example.NORAM/CRD_CL/AD9H3_nCL/label/X86_UBUNTU
LocalWorkspace=$WORKSPACE # $WORKSPACE-&gt; Jenkins global variable

# Example: WorkspaceName= SNAP_IMG_CAPI2_matrix@2  (@2 used if one build is running when starting a 2nd build)
WorkspaceName=`echo $LocalWorkspace | sed &quot;s%^.*$RootJobName%$RootJobName%&quot; | cut -d&quot;/&quot; -f1`

# Example: LocalRootWorkspace= /var/jenkins/workspace/SNAP_IMG_CAPI2_matrix@2
LocalRootWorkspace=&quot;`echo $LocalWorkspace | awk -F&quot;/$WorkspaceName/&quot; &apos;{print $1}&apos;`/$WorkspaceName&quot;

LSFRoot=&quot;/afs/bb/proj/fpga&quot;

# Example: LSFRootWorkspace= /afs/bb/proj/fpga/framework/CI_ws/SNAP_IMG_CAPI2_matrix (@2 name is not planned in $LSFRoot/framework/CI_ws)
LSFRootWorkspace=&quot;$LSFRoot/framework/CI_ws/$RootJobName&quot;

# Example: LSFWorkspace= /afs/bb/proj/fpga/framework/CI_ws/SNAP_IMG_CAPI2_matrix/master/ACT/hdl_example.NORAM/CRD_CL/AD9H3_nCL/label/X86_UBUNTU
LSFWorkspace=&quot;$LSFRootWorkspace/`echo $LocalWorkspace | awk -F&quot;$LocalRootWorkspace/&quot; &apos;{print $2}&apos;`&quot;



# LSFLoginServer, RootWorkspace variables... or RootWorkspace pointing to local dir
if [ &quot;$LSF_CLUSTER&quot; == &quot;true&quot; ]; then
  echo;echo &quot;****************************************************************************************&quot;
  echo &quot;J:LSF Login Server SETUP ...&quot;
  
  # Boeblingen LSF cluster Login Servers
  LSFLoginServersList=&quot;\
  hdcl050.boeblingen.de.ibm.com
  hdcl051.boeblingen.de.ibm.com
  hdcl052.boeblingen.de.ibm.com
  hdcl027.boeblingen.de.ibm.com
  hdcl060.boeblingen.de.ibm.com
  hdclp026.boeblingen.de.ibm.com&quot;
  
  LSFLoginServer=&quot;&quot;
  for i in $LSFLoginServersList; do
    if ping -c1 $i &gt;/dev/null 2&gt;&amp;1; then 
      LSFLoginServer=$i
      break
    fi
  done

  if [[ &quot;$LSFLoginServer&quot; != &quot;&quot; ]]; then
    echo &quot;  -&gt; LSF Login Server = $LSFLoginServer&quot;
    echo &quot;  -&gt; LSF Root workspace = $LSFRootWorkspace&quot;
  else
    echo &quot;  -&gt; no LSF Login Server available ! Exiting&quot;
    exit 1
  fi

fi



#==============================================================================================
# Functions

# Function for sending alerting emails
# Example 1: SendAnEmail -s &quot;This is the subject/alert&quot; -d firstDest@gmail.com -d SecondDest@free.fr
# Example 2: SendAnEmail -s &quot;This is the subject/alert&quot; -d &quot;${EmailDestinationList[*]}&quot;
function SendAnEmail
{
  local OPTIND opt DestList
  while getopts &quot;s:d:&quot; opt
  do 
    case $opt in
      s)
        Subject=&quot;$OPTARG&quot;
      ;;
      d)
        DestList+=(&quot;$OPTARG&quot;)
      ;;
    esac
  done
  
  for i in ${DestList[@]}
  do
    echo &quot;&quot; | mail -s &quot;$Subject&quot; $i
  done
}


#==============================================================================================
# Do not run non-desired cases (action types, actions, cards)
# BSKIP stands for board skip

echo;echo &quot;*******************************************************************************&quot;
echo &quot;J: Do not run (abort) non-desired cases (action types, actions, cards)&quot;


BSKIP=0
 
&lt;&lt; //// # FAB: Matrix Combination Filter plugin implementation

if [ &quot;${!ACTION_TYPE}&quot; == &quot;false&quot; ]; then BSKIP=1;fi # if ACTION_TYPE=&quot;HLS&quot;, ${!ACTION_TYPE} is identical to $HLS
if [ &quot;${!CRDSuffix}&quot;         == &quot;false&quot; ]; then BSKIP=1;fi # if CRDSuffix=&quot;AD9V3&quot;, ${!CRDSuffix} is identical to $AD9V3
if [ &quot;$ACT&quot;            == &quot;test&quot;  ]; then BSKIP=0;fi

echo &quot;  -&gt; action_types (hdl,hls)=$ACTION_TYPE enabled_cards=$CRD BSKIP=$BSKIP&quot;

////

# Following filtering will stop the current test if not required or not possible
# This will lead to a brown colored result meaning : aborted
# ASKIP stands for ACTION skip

case &quot;$CRD:$ACT&quot; in
  
  OC-AD9H7:hls_memcopy_1024 ) # oc-accel/hardware/oc-bip/board_support_packages/ad9h7/xdc/snap_hbm_timing.xdc does not exist
    C=&quot;unsupported &quot;
    ASKIP=1
    ;;
    
  * )
    C=&quot;def &quot;  # def=default
    ASKIP=0
    ;;
esac        

echo &quot;  -&gt; card=$CRD action=$ACT case=$C ASKIP=$ASKIP&quot;


#==============================================================================================
# Cleaning directories if ACT=test,
# else checking $CRD.$ACT.defconfig file existence

echo;echo &quot;*******************************************************************************&quot;

if [ $ASKIP -eq 0 ]
then 

 case &quot;$ACT&quot; in
 
  test )
    echo &quot;J: ACT=test&quot;
    echo
    gitnames=`git ls-remote ${GIT_URL}|grep &quot;refs/heads/&quot;|awk &apos;{print $2}&apos;`
    echo &quot;gitnames= $gitnames&quot;

    if [ &quot;$LSF_CLUSTER&quot; == &quot;true&quot; ]; then
      # First time calling ssh, &quot;StrictHostKeyChecking no&quot; updates .ssh/known_hosts file without asking
      WorkspaceDirList=`sshpass -p $AFSPass ssh -o &quot;StrictHostKeyChecking no&quot; $AFSUser@$LSFLoginServer &quot;ls -d $LSFRootWorkspace/*/&quot;`
    else
      WorkspaceDirList=`ls -d $LocalRootWorkspace/*/`
    fi

    echo
    for dir in $WorkspaceDirList;do    
      branch=&quot;refs/heads/&quot;`basename $dir`

      if [[ &quot;$gitnames&quot; =~ &quot;$branch&quot; ]];then
        echo &quot;branch=$branch found in gitnames, keeping dir=$dir&quot;
      else 
        echo &quot;branch=$branch not found in gitnames, deleting dir=\&apos;$dir\&apos;&quot;
        if [ &quot;$LSF_CLUSTER&quot; == &quot;true&quot; ]; then
          sshpass -p $AFSPass ssh $AFSUser@$LSFLoginServer rm -rf &quot;$dir&quot;
        else
          rm -rf &quot;$dir&quot;     # put in quotes to work for directories with blanks
        fi
      fi
    done
    
    DSKIP=0
    ;;

  * )
    echo &quot;J: Checking oc-accel/defconfig/$CRD.$ACT.defconfig existence&quot;
    if [ -f oc-accel/defconfig/$CRD.$ACT.defconfig ]
    then
      echo &quot; --&gt; OK&quot;
      DSKIP=0
    else 
      echo;echo &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;
      echo &quot;$CRD.$ACT.defconfig does not exist&quot;
      echo &quot;Aborting...&quot;
      echo &quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;;echo
      echo; ls oc-accel/defconfig/
      DSKIP=1
    fi
    ;;
    
 esac

 echo;echo &quot;defconfig DSKIP=$DSKIP&quot;


#==============================================================================================
# Checking enough space is available

 echo;echo &quot;*******************************************************************************&quot;
 echo &quot;J: Checking enough space is available&quot;

 if [ &quot;$LSF_CLUSTER&quot; == &quot;true&quot; ]; then
   # First time calling ssh, &quot;StrictHostKeyChecking no&quot; updates .ssh/known_hosts file without asking
   diskused=`sshpass -p $AFSPass ssh -o &quot;StrictHostKeyChecking no&quot; $AFSUser@$LSFLoginServer &quot;fs lq $LSFRootWorkspace&quot; |grep -v Used|awk &apos;{print $4}&apos;|sed &apos;s/%//g&apos;|sed &apos;s/&lt;//g&apos;`
   msg=&quot;$LSFRootWorkspace disk usage =${diskused}%&quot;
 else
   diskused=`df -h $LocalRootWorkspace |grep -v Used|awk &apos;{print $5}&apos;|sed &apos;s/%//g&apos;|sed &apos;s/&lt;//g&apos;`
   msg=&quot;$LocalRootWorkspace disk usage =${diskused}%&quot;
 fi

 SSKIP=0

 if   (( diskused &gt; 90 ));then 
   msg=&quot;ERROR: $msg, stopping additional builds&quot;;SSKIP=1
   if [ $EmailOrNotEmail -eq 1 ]; then
     SendAnEmail -s &quot;ERROR: Disk space is used up to ${diskused}%, stopping additional builds&quot; -d &quot;${EmailDestinationList[*]}&quot;
     #SendAnEmail -s &quot;ERROR: AFS space is used up to ${AFSused}%, stopping additional builds&quot; -d &quot;${EmailDestinationList[*]}&quot;  
   fi 

 elif (( diskused &gt; 70 ));then
    msg=&quot;WARNING: $msg&quot;
    if [ $EmailOrNotEmail -eq 1 ]; then
      SendAnEmail -s &quot;WARNING: Disk space is used up to ${diskused}%&quot; -d &quot;${EmailDestinationList[*]}&quot;
      #SendAnEmail -s &quot;WARNING: AFS space is used up to ${AFSused}%&quot; -d &quot;${EmailDestinationList[*]}&quot;  
    fi

 else
    msg=&quot;  -&gt; OK: $msg&quot;
 fi

 echo &quot;$msg&quot;


fi # end of if ASKIP


#==============================================================================================
# Aborting if something went wrong

if [ &quot;$ASKIP&quot; == &quot;1&quot; ] || [ &quot;$DSKIP&quot; == &quot;1&quot; ] || [ &quot;$BSKIP&quot; == &quot;1&quot; ] || [ &quot;$SSKIP&quot; == &quot;1&quot; ];then SKIP=1;else SKIP=0;fi


#==============================================================================================
# Passing parameters to next script

echo;echo &quot;*******************************************************************************&quot;
echo &quot;J: Forwarding parameters to next script&quot;
echo
echo &quot;SKIP=$SKIP&quot; &gt;&gt; export_props.properties
echo &quot;CRD=$CRD&quot; &gt;&gt; export_props.properties
echo &quot;CL=$CL&quot; &gt;&gt; export_props.properties
echo &quot;EmailDestinationList=( ${EmailDestinationList[*]} )&quot; &gt;&gt; export_props.properties
echo &quot;EmailOrNotEmail=$EmailOrNotEmail&quot; &gt;&gt; export_props.properties
echo &quot;HWUser=${HWUser}&quot; &gt;&gt; export_props.properties
echo &quot;LSFLoginServer=${LSFLoginServer}&quot; &gt;&gt; export_props.properties
echo &quot;LocalRootWorkspace=${LocalRootWorkspace}&quot; &gt;&gt; export_props.properties
echo &quot;LocalWorkspace=${LocalWorkspace}&quot; &gt;&gt; export_props.properties
echo &quot;LSFRoot=${LSFRoot}&quot; &gt;&gt; export_props.properties
echo &quot;LSFRootWorkspace=${LSFRootWorkspace}&quot; &gt;&gt; export_props.properties
echo &quot;LSFWorkspace=${LSFWorkspace}&quot; &gt;&gt; export_props.properties

echo &quot;properties forwarded to next shell:&quot;
cat export_props.properties
echo;echo &quot;*******************************************************************************&quot;
echo</command>
    </hudson.tasks.Shell>
    <EnvInjectBuilder plugin="envinject@2.1.6">
      <info>
        <propertiesFilePath>export_props.properties</propertiesFilePath>
      </info>
    </EnvInjectBuilder>
    <org.jenkinsci.plugins.conditionalbuildstep.singlestep.SingleConditionalBuilder plugin="conditional-buildstep@1.3.6">
      <condition class="org.jenkins_ci.plugins.run_condition.core.BooleanCondition" plugin="run-condition@1.2">
        <token>$SKIP</token>
      </condition>
      <buildStep class="org.jenkins_ci.plugins.fail_the_build.FixResultBuilder" plugin="fail-the-build-plugin@1.0">
        <defaultResultName>ABORTED</defaultResultName>
        <success></success>
        <unstable></unstable>
        <failure></failure>
        <aborted></aborted>
      </buildStep>
      <runner class="org.jenkins_ci.plugins.run_condition.BuildStepRunner$Fail" plugin="run-condition@1.2"/>
    </org.jenkinsci.plugins.conditionalbuildstep.singlestep.SingleConditionalBuilder>
    <hudson.tasks.Shell>
      <command>#!/bin/bash

set +x                            # reduce Jenkins output
ulimit -c unlimited               # limit core dumps

echo;echo &quot;****************************************************************************************&quot;
echo &quot;EXECUTING SECOND OpenCAPI SHELL FROM MOPJENKINS (`date`)&quot;
echo &quot;****************************************************************************************&quot;

echo &quot;Building with Card=$CRD Action=$ACT CLOUD=$CL&quot;


#==============================================================================================
# Variables

export PATH=$PATH:/usr/local/bin  # python3 needs this path setup
export USERHOME=`pwd`
export OCACCEL_ROOT=$USERHOME/oc-accel

TESTBOXES=( ${mopBoxes[*]} ${austinBoxes[*]} ) # init array of systems
echo &quot;testboxes now = ${TESTBOXES[@]}&quot;

RootSaveDir=/data/Images
SaveDir=${RootSaveDir}/${CRD}/${CRD}_IMAGES
RootLogsDir=/data/LogsWhenFailed
LogsDir=$RootLogsDir/${BUILD_NUMBER}-${JOB_NAME}-${GIT_BRANCH}/hardware

IMGServers=&quot;jtagx86&quot; # List of servers where to push generated images.

SudoOrNotSudo=&quot;sudo&quot; # =&quot;sudo&quot; or &quot;&quot; if sudo not needed to access /dev/cxl

# Setup $VIV_VERSION

echo;echo &quot;****************************************************************************************&quot;
echo &quot;J: Setting up Vivado Version&quot;
if [ &quot;$VIVADO_GLOBAL&quot; == &quot;--&quot; ]; then
  VIVADOVarName=`echo VIVADO_$CRD`
  export VIV_VERSION=${!VIVADOVarName}
  echo &quot; --&gt; For $CRD card, VIVADO version initially set to $VIV_VERSION...&quot;

else
  export VIV_VERSION=$VIVADO_GLOBAL
  echo &quot; --&gt; For all cards, VIVADO version initially set to $VIV_VERSION...&quot;
fi

# Initial LSF setup (LSFSource, LSFBsubRun, LSFRun)

if [ &quot;$LSF_CLUSTER&quot; == &quot;true&quot; ]; then
  echo;echo &quot;****************************************************************************************&quot;
  echo &quot;J:LSF SETUP ...&quot;
  echo
  echo &quot;LSF Login Server = $LSFLoginServer&quot;
  echo &quot;  -&gt; LSF Root workspace = $LSFRootWorkspace&quot;


# Building $LSFRun, $LSFBsubRun &amp; $LSFSource scripts locally as $LocalWorkspace will be lately scp to LSF cluster:$LSFWorkspace

#-----------------------------------------------------------------------------------------------------------------------------
# LSFSource: source file which includes environment variables
  
  LSFSource=LSFSource.sh

  cat &lt;&lt; EOF &gt; $LocalWorkspace/$LSFSource
# LSF cluster environment variables

# -&gt; older setup up to RH6
export PATH=\$PATH:/usr/local/bin:/home/lsfbb/prod/10.1/linux2.6-glibc2.3-x86_64/bin
export LSF_SERVERDIR=/home/lsfbb/prod/10.1/linux2.6-glibc2.3-x86_64/etc
export LSF_LIBDIR=/home/lsfbb/prod/10.1/linux2.6-glibc2.3-x86_64/lib
export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:/home/lsfbb/prod/10.1/linux2.6-glibc2.3-x86_64/lib
export LSF_BINDIR=/home/lsfbb/prod/10.1/linux2.6-glibc2.3-x86_64/bin

# -&gt; new setup for RH7
#export PATH=\$PATH:/usr/local/bin:/home/lsfbb/prod/10.1/linux3.10-glibc2.17-x86_64/bin
#export LSF_SERVERDIR=/home/lsfbb/prod/10.1/linux3.10-glibc2.17-x86_64/etc
#export LSF_LIBDIR=/home/lsfbb/prod/10.1/linux3.10-glibc2.17-x86_64/lib
#export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:/home/lsfbb/prod/10.1/linux3.10-glibc2.17-x86_64/lib
#export LSF_BINDIR=/home/lsfbb/prod/10.1/linux3.10-glibc2.17-x86_64/bin

# -&gt; in all cases
export LSF_SUBMITTER_OSTYPE=Linux
export LSF_ENVDIR=/home/lsfbb/prod/conf

# LSF bsub submission settings
LSF=&quot;-P zsort&quot;            # project name
LSF+=&quot; -M 6&quot;              # per-process (soft) memory limit for all processes that belong to this job. LSF_UNIT_FOR_LIMITS=MB ($LSF_ENVDIR/lsf.conf)
LSF+=&quot; -C 2000&quot;           # per-process (soft) core file size limit for all processes that belong to this job. LSF_UNIT_FOR_LIMITS=MB ($LSF_ENVDIR/lsf.conf)
LSF+=&apos; -R osver=rh7&apos;      # Asking for RHEL7 which is madatory for Vivado 2019.1 and higher
LSF+=&apos; -R type==X86_64&apos;   # Vivado make image only runs onto X86 platform
LSF+=&apos; -R span[hosts=1]&apos;  # Ensure the job runs on only 1 host (not running across the hosts)
LSF+=&apos; -I&apos;                # interactive job so Jenkins displays job outputs and waits for the job to finish
LSF+=&apos; -n 8&apos;              # Submitting a parallel job and specifying the number of processors required to run the job 
export LSF

# Build parameters
export CRD=$CRD
export ACT=$ACT
export VIV_VERSION=$VIV_VERSION
export OCACCEL_ROOT=$LSFWorkspace/oc-accel

# VIVADO parameters
export XILINX_ROOT=$LSFRoot/xilinx
export XILINXD_LICENSE_FILE=2100@pokwinlic1.pok.ibm.com
source \$XILINX_ROOT/Vivado/${VIV_VERSION}/settings64.sh

EOF

  echo &quot;  -&gt; LSF Source script = $LocalWorkspace/$LSFSource&quot;



#-----------------------------------------------------------------------------------------------------------------------------
# LSFBsubRun: script which will be bsub at LSF Cluster node to build the image

  LSFBsubRun=LSFBsubRun.bash

  cat &lt;&lt; EOF &gt; $LocalWorkspace/$LSFBsubRun
#!/bin/bash

echo; echo &quot;###########################################################################################&quot;
echo &quot;LSF Cluster Node info:&quot;
echo &quot;----------------------&quot;
hostname
{ [ -f /etc/os-release ] &amp;&amp; grep PRETTY_NAME /etc/os-release | cut -d= -f2 ; } || { [ -f /etc/system-release ] &amp;&amp; cat /etc/system-release ; }
uname -a
echo; echo &quot;lscpu:&quot; 
lscpu
echo; echo &quot;free -h:&quot;
free -h

echo; echo &quot;###########################################################################################&quot;
echo &quot;  -&gt; Cleaning (make clean) \$OCACCEL_ROOT directory&quot;
cd \$OCACCEL_ROOT
make clean                   # to make sure we restart from a blank snap

echo; echo &quot;###########################################################################################&quot;
echo Command: make image

make image

EOF

  chmod +x $LocalWorkspace/$LSFBsubRun
  echo &quot;  -&gt; LSF Bsub script = $LocalWorkspace/$LSFBsubRun&quot;



#-----------------------------------------------------------------------------------------------------------------------------
# LSFRun: script which will be run at LSF Cluster Login server to push the bsub
  
  LSFRun=LSFRun.bash
  
  cat &lt;&lt; EOF &gt; $LocalWorkspace/$LSFRun
#!/bin/bash

. $LSFSource

echo; echo &quot;###########################################################################################&quot;
echo &quot;LSF Cluster Login Server info:&quot;
echo &quot;------------------------------&quot;
hostname

echo; echo &quot;###########################################################################################&quot;
echo Command: bsub \$LSF -J &quot;\${CRD}_\${ACT}_image&quot; $LSFWorkspace/$LSFBsubRun

cd \$OCACCEL_ROOT
bsub \$LSF -J &quot;\${CRD}_\${ACT}_image&quot; $LSFWorkspace/$LSFBsubRun

EOF

  chmod +x $LocalWorkspace/$LSFRun
  echo &quot;  -&gt; LSF Run script = $LocalWorkspace/$LSFRun&quot;
  

fi 


## older setup up to RH6
##LSF=&apos;-P zsort -M 2 -C 2000 -I -n 4 -R type=X86_64 -R span[hosts=1]&apos;  # Project, GB_mem, KB_core, #_processors, type of processor

# new setup for RH7
#LSF=&apos;-P zsort -M 2 -C 2000 -I -n 4 -R type=X86_64  -R osver=rh7 -R span[hosts=1]&apos;  # Project, GB_mem, KB_core, #_processors, type of processor


#==============================================================================================
# Functions

# Function for sending alerting emails
# Example 1: SendAnEmail -s &quot;This is the subject/alert&quot; -d firstDest@gmail.com -d SecondDest@free.fr
# Example 2: SendAnEmail -s &quot;This is the subject/alert&quot; -d &quot;${EmailDestinationList[*]}&quot;
function SendAnEmail
{
  local OPTIND opt DestList
  while getopts &quot;s:d:&quot; opt
  do 
    case $opt in
      s)
        Subject=&quot;$OPTARG&quot;
      ;;
      d)
        DestList+=(&quot;$OPTARG&quot;)
      ;;
    esac
  done
  
  for i in ${DestList[@]}
  do
    echo &quot;&quot; | mail -s &quot;$Subject&quot; $i
  done
}


# Function to copy BIN, BIT, MCS, PRM, etc to the right directory
# Example 1: CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s jtagx86 -u $HWUser
# Example 2: CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -s jtagx86 -u $HWUser
# Example 3: CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;jtagx86 orpington&quot; -u $HWUser
# Example 4: CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
# -f should use &quot;&quot; as $SRCFILES are usually lists of files like &quot;primary.bin secondary.bin&quot;

function CopyToDir
{
  local OPTIND opt FPGACard SrcFiles ToDir LkDir SSHDest SSHUser

  while getopts &quot;c:f:d:l:s:u:&quot; opt
  do
      case $opt in
      c)
        FPGACard=&quot;$OPTARG&quot;
      ;;
      f)
        SrcFiles=&quot;$OPTARG&quot;
      ;;
      d)
        ToDir=&quot;$OPTARG&quot;
      ;;
      l)
        LkDir=&quot;$OPTARG&quot;
      ;;
      s)
        SSHDest=&quot;$OPTARG&quot;
      ;;
      u)
        SSHUser=&quot;$OPTARG&quot;
      ;;
    esac
  done

  ToDirFiles=&quot;&quot;
  for i in $SrcFiles; do ToDirFiles=&quot;$ToDirFiles $ToDir/`basename $i`&quot;; done


  # Copying Files to $ToDir
  echo &quot;  -&gt; Copying $FPGACard images (.bin, .bit, .mcs, .prm) to $ToDir&quot;
  mkdir -p $ToDir
  chmod g+w `dirname $ToDir` # /data/Images/OC-AD9V3/OC-AD9V3_IMAGES, we need to chmod /data/Images/OC-AD9V3 if we just created /data/Images/OC-AD9V3
  chmod g+w $ToDir           # and chmod /data/Images/OC-AD9V3/OC-AD9V3_IMAGES
  cp -rp $SrcFiles $ToDir
  chmod 664 $ToDirFiles      # giving rw- attributs for user &amp; group and r-- for other
      
  for dest in $SSHDest
  do
    echo;echo &quot;  -&gt; Copying $FPGACard images to $dest:$ToDir&quot;
    ssh ${SSHUser}@$dest &quot;mkdir -p $ToDir; chmod g+w $ToDir&quot;
    scp -rp $SrcFiles ${SSHUser}@$dest:$ToDir
    ssh ${SSHUser}@$dest &quot;chmod 664 $ToDirFiles&quot;      # giving rw- attributs for user &amp; group and r-- for other
  done

  # Building symbolic links into $LkDir
  if [ &quot;$LkDir&quot; != &quot;&quot; ]; then
    echo &quot;  -&gt; Building $FPGACard images links into $LkDir&quot;
    mkdir -p $LkDir
    chmod g+w $LkDir
    ln -s $ToDirFiles $LkDir

    for i in $ToDirFiles; do echo -e &quot;/\c&quot;;ls -la $LkDir/`basename $i` | cut -d &quot;/&quot; -f2-; done

    for dest in $SSHDest
    do
      echo;echo &quot;  -&gt; Building $FPGACard images links into $dest:$LkDir&quot;
      ssh ${SSHUser}@$dest &quot;mkdir -p $LkDir; chmod g+w $LkDir&quot;
      ssh ${SSHUser}@$dest &quot;ln -s $ToDirFiles $LkDir&quot;
      for i in $ToDirFiles; do ssh ${SSHUser}@$dest &quot;echo -e &apos;/\c&apos;;ls -la $LkDir/`basename $i` | cut -d &apos;/&apos; -f2-&quot;; done
    done
  fi
}



#==============================================================================================
#==============================================================================================
# MAIN starts here !
#==============================================================================================
#==============================================================================================


#==============================================================================================
# OpenCAPI Simulation Engine (ocse) setup
# Should not be used but may be required by ??

echo;echo &quot;*******************************************************************************&quot;
echo &quot;J: Getting OpenCAPI Simulation Environment (ocse)...&quot;
echo
echo;echo &quot;Current directory is : $PWD&quot;
ls -al

echo;echo &quot;  -&gt; Deleting old ./ocse (OpenCAPI Simulation Engine) directory&quot;
rm -rf ocse

# When Lance Thomson makes a mod in his OCSE, we might use a specific branch for test
# 2019 Nov 04 he merged the issue_2 into master (removing the debug messages)

echo;echo &quot;  -&gt; Getting (git clone) OpenCAPI Simulation Environment (ocse) branch=$OCSE_BRANCH for card=$CRD...&quot;
git clone -b $OCSE_BRANCH https://github.com/OpenCAPI/ocse ocse;echo &quot;git clone OCSE RC=$?&quot;

export OCSE_INSTALL_DIR=${USERHOME}/ocse   # ca ne sert à rien on dirait !!
echo;echo &quot;  -&gt; Exporting ocse directory as : ${USERHOME}/ocse into snap_env.sh&quot;
echo &quot;export OCSE_ROOT=${USERHOME}/ocse&quot; &gt;snap_env.sh

echo;echo &quot;  -&gt; Exporting XILINX_LOCAL_USER_DATA=no into snap_env.sh&quot;
echo &quot;#setup: XILINX_LOCAL_USER_DATA=${XILINX_LOCAL_USER_DATA}, overwrite=no to prevent write access error in XilincTclStore (tclapp:load_apps)&quot; &gt;&gt;snap_env.sh
echo &quot;export XILINX_LOCAL_USER_DATA=no&quot; &gt;&gt; snap_env.sh

#==============================================================================================
# Cleaning previous TL/DL &amp; getting TL:DL zip files

# FAB a vérifier si encore nécessaire. A priori non
#echo;echo &quot;****************************************************************************************&quot;
#echo &quot;J: Cleaning any previous TL/DL and getting TL/DL zip files&quot;
#echo
#cd ${OCACCEL_ROOT}
#make clean                    # to make sure we restart from a blank snap
#rm -rf hardware/oc-bip        # to make sure we restart from a blank capi-bsp
#echo &quot;J: git cloning oc-bip&quot;
#git submodule init            # to get the oc-bip
#git submodule update
# collecting the TL/DL definition
#echo &quot;J: Getting the zip file for tlx and dlx&quot;
#cp -r /afs/bb/proj/fpga/framework/cards/$CRD/tlx ./hardware/oc-bip/
#cp -r /afs/bb/proj/fpga/framework/cards/$CRD/dlx ./hardware/oc-bip/


#==============================================================================================
# Setting up Timing value

echo;echo &quot;****************************************************************************************&quot;
echo &quot;J: Setting up timing value&quot;

echo
echo &quot; --&gt; For all CAPI2 cards we extend Timing trials to 5 runs until we optimise placement...&quot;
echo &quot;     unless expressly indicated&quot;


cd ${OCACCEL_ROOT}

echo &quot;export TIMING_LABLIMIT=\&quot;${TIMING_LABLIMIT_CHOICE}\&quot;&quot; &gt;&gt; snap_env.sh
echo &quot;TIMING LIMIT set to ${TIMING_LABLIMIT_CHOICE} into snap_env.sh&quot;

echo;echo &quot;****************************************************************************************&quot; 
echo &quot;J: Vivado paths &amp; licences server setup ...&quot;
export XILINX_ROOT=/opt/Xilinx
export XILINXD_LICENSE_FILE=2100@pokwinlic1.pok.ibm.com
echo &quot;J: sourcing $XILINX_ROOT/Vivado/${VIV_VERSION}/settings64.sh&quot;
source $XILINX_ROOT/Vivado/${VIV_VERSION}/settings64.sh


#==============================================================================================
# Cadence setup

# FAB: No cadence setup at MOP
#echo;echo &quot;****************************************************************************************&quot; 
#echo &quot;J: Cadence SETUP ...&quot;
#echo
#echo &quot;IES_LIBS=$IES_LIBS&quot;
#echo &quot;CDS_LIC_FILE=$CDS_LIC_FILE&quot;


#==============================================================================================
# Testing POWER servers accessibility if ACT=test and TEST_ON_HW=true,
# else making $CRD.$ACT.defconfig 

echo;echo &quot;****************************************************************************************&quot;

case $ACT in          # select config &amp; compile action

  &quot;test&quot;)
    echo &quot;J: ACT=$ACT ==&gt; skipping image building&quot;;echo
    
  	if [ &quot;$TEST_ON_HW&quot; == &quot;true&quot; ]; then 

        echo &quot;Test on Hardware selected ==&gt; testing POWER servers accessibility:&quot;
        # Cleaning will occur at this step, remote fw*.bin* files older than $days will be removed
        days=90;srch=&quot;&apos;fw*.bin*&apos;&quot;
      
      for box in &quot;${TESTBOXES[@]}&quot;;do
        echo &quot;----------------------------------------------------&quot;
        # First time calling ssh, &quot;StrictHostKeyChecking no&quot; updates .ssh/known_hosts file without asking
        # connecTimeout=X just gives back after X seconds if system is not answering instead of freezing the job
        if [[ ${mopBoxes[*]} =~ $box ]]
        then
          # $box is a Montpellier server
          echo -e &quot;MOP   : $box -&gt; \c&quot;
          RC=0;ssh -o connectTimeout=5 -o &quot;StrictHostKeyChecking no&quot; ${HWUser}@$box ping localhost -c1 &gt;/dev/null 2&gt;&amp;1 || RC=$?
        else
          echo -e &quot;AUSTIN: $box -&gt; \c&quot;
          RC=0;ssh -o connectTimeout=5 -o &quot;StrictHostKeyChecking no&quot; ${HWUser}@$box ping localhost -c1 &gt;/dev/null 2&gt;&amp;1 || RC=$?
        fi
      
        if [ $RC == &quot;0&quot; ]; then echo &quot;OK&quot;; else echo &quot;FAILED&quot;;continue;fi
        
        echo &quot;Cleaning process : ssh ${HWUser}@$box find &amp; delete $srch in /home/$HWUser older than $days days&quot;
        ssh ${HWUser}@$box &quot;find /home/$HWUser -type f -name $srch -mtime +$days -ls -delete&quot;
        nusers=`ssh ${HWUser}@${box} who|grep -v root|grep -v ${HWUser}|wc -l`
        echo &quot;box=$box nusers=$nusers (`date`)&quot;
      done
    fi                          
    exit 0                     
    ;;
    
  *&quot;nvme&quot;*|*&quot;NVME&quot;*)
    echo &quot;J: ACT=*NVME* ==&gt; SIMULATOR=nosim &amp; Configuring image thanks to $CRD.$ACT.defconfig file ...&quot;;echo
    echo &quot;export SIMULATOR=nosim&quot; &gt;&gt; snap_env.sh
    make -s $CRD.$ACT.defconfig
    ;;
    
  *)
    echo &quot;J: Generic case ==&gt; Just configuring image thanks to $CRD.$ACT.defconfig file...&quot;;echo
    make -s $CRD.$ACT.defconfig
    ;;
esac


#==============================================================================================
# Building image (make image/ make cloud...)

if [ &quot;$CL&quot; == &quot;nCL&quot; ]
then

  if [ &quot;$LSF_CLUSTER&quot; == &quot;true&quot; ]; then
    
    # Modify snap_env.sh to match configuration of the LSF Cluster

    echo;echo &quot;****************************************************************************************&quot;
    echo &quot;J: Modifying snap_env.sh to match configuration of the LSF Cluster&quot;
    
    cp $OCACCEL_ROOT/snap_env.sh $OCACCEL_ROOT/Mopjenkins_snap_env.sh
    
    mv $OCACCEL_ROOT/snap_env.sh $OCACCEL_ROOT/temp_snap_env.sh    
    cat $OCACCEL_ROOT/temp_snap_env.sh | sed &quot;s%export OCSE_ROOT=.*%export OCSE_ROOT=$LSFWorkspace/ocse%&quot; &gt; $OCACCEL_ROOT/snap_env.sh
    
    echo;echo &quot;New LSF snap_env.sh:&quot;
    cat $OCACCEL_ROOT/snap_env.sh
    
    rm $OCACCEL_ROOT/temp_snap_env.sh

    # Copying (rsync) $LocalWorkspace --&gt; $LSFWorkspace

    echo;echo &quot;****************************************************************************************&quot;
    echo &quot;J: Copying (rsync)...&quot;
    echo &quot;     $LocalWorkspace&quot;
    echo &quot;    --&gt;&quot;
    echo &quot;     $LSFWorkspace&quot;

    sshpass -p $AFSPass ssh $AFSUser@$LSFLoginServer &quot;rm -rf $LSFWorkspace&quot;
    sshpass -p $AFSPass ssh $AFSUser@$LSFLoginServer &quot;mkdir -p `dirname $LSFWorkspace`&quot;
    sshpass -p $AFSPass rsync -az $LocalWorkspace $AFSUser@$LSFLoginServer:`dirname $LSFWorkspace`
  fi

  # $maxloop number of tentative to try and make the image
  
  maxloop=5;
  for loop in `seq 1 $maxloop`
  do  
    echo;echo &quot;****************************************************************************************&quot;
    echo &quot;J: Build Non-Cloud Image (make image) for $CRD, Loop ${loop}/$maxloop (`date`)&quot;

    if [ &quot;$LSF_CLUSTER&quot; == &quot;true&quot; ]; then
      echo;echo &quot;  -&gt; Building the Image (make image) with LSF Cluster&quot;
      echo;echo &quot;     Executing on $LSFLoginServer:&quot;
      echo &quot;       cd $LSFWorkspace&quot;
      echo &quot;       ./$LSFRun&quot;

      RC=0; sshpass -p $AFSPass ssh $AFSUser@$LSFLoginServer &quot;cd $LSFWorkspace; ./$LSFRun&quot; &amp;&amp; break || RC=$?
      
    else
      echo;echo &quot;  -&gt; Building the Image (make image) locally&quot;
      echo;echo &quot;  -&gt; Cleaning (make clean) $OCACCEL_ROOT &amp; $OCACCEL_ROOT/hardware/capi2-bsp directories&quot;
      cd $OCACCEL_ROOT
      make clean                   # to make sure we restart from a blank snap
      RC=0; make image &amp;&amp; break || RC=$?
    fi
    
  done
  
  # Copying BACK (rsync) $LocalWorkspace --&gt; $LSFWorkspace if using LSF cluster
  
  if [ &quot;$LSF_CLUSTER&quot; == &quot;true&quot; ]; then
    echo;echo &quot;****************************************************************************************&quot;
    echo &quot;J: Copying BACK (rsync) whether build is good (for images) or not (for logs)...&quot;
    echo &quot;     $LSFWorkspace&quot;
    echo &quot;    --&gt;&quot;
    echo &quot;     $LocalWorkspace&quot;

    sshpass -p $AFSPass rsync -az $AFSUser@$LSFLoginServer:$LSFWorkspace `dirname $LocalWorkspace`
  fi
  
  # Checking the result of the make image operation
  
  echo;echo &quot;****************************************************************************************&quot;
  echo &quot;J: RESULT for Non-Cloud Image build (make image) for $CRD, Loop ${loop}/$maxloop (`date`)&quot;  

  if [ $RC -eq 0 ] &amp;&amp; [ $loop -eq 1 ]; then 
    echo &quot;OK : ${CRD}_${ACT}_image :-make image- : TIMING SUCCEEDED at the first try (loop=$loop)&quot;

  elif [ $RC -eq 0 ] &amp;&amp; [ $loop -gt 1 ]; then
    echo &quot;WARNING : ${CRD}_${ACT}_image :-make image- : TIMING SUCCEEDED after $loop loop(s)&quot;
    if [ $EmailOrNotEmail -eq 1 ]; then
      echo &quot;  -&gt; Sending an email to ${EmailDestinationList[*]}&quot;
      SendAnEmail -s &quot;WARNING : ${CRD}_${ACT}_image :-make image- : TIMING SUCCEEDED after $loop loop(s)&quot; -d &quot;${EmailDestinationList[*]}&quot;
    fi

  elif [ $RC -ne 0 ]; then
    echo &quot;ERROR : ${CRD}_${ACT}_image :-make image- : TIMING FAILED after $maxloop loop(s)&quot;
    if [ $EmailOrNotEmail -eq 1 ]; then
      echo &quot;  -&gt; Sending an email to ${EmailDestinationList[*]}&quot;    
      SendAnEmail -s &quot;ERROR : ${CRD}_${ACT}_image :-make image- : TIMING FAILED after $maxloop loop(s)&quot; -d &quot;${EmailDestinationList[*]}&quot;
    fi
    
    exit 1
  fi

else # case of Cloud Build
# FAB never for the moment but if needed, needs to adapt (BSUB, etc)
  mkdir -p ${OCACCEL_ROOT}/hardware/DCPs
  echo;echo &quot;****************************************************************************************&quot;
  echo &quot;J: Build Cloud Image ...&quot;
  echo &quot;export DCP_ROOT=${OCACCEL_ROOT}/hardware/DCPs/&quot;              &gt;&gt; snap_env.sh
  echo &quot;ENABLE_PRFLOW=y&quot;                                          &gt;&gt; .snap_config
  echo &quot;ENABLE_CLOUD_USER_FLOW=n&quot;                                 &gt;&gt; .snap_config
  echo &quot;ENABLE_CLOUD_BUILD_BITFILE=n&quot;                             &gt;&gt; .snap_config
  make -s oldconfig
  echo &quot;J: Build Static Region ...&quot;
  bsub $LSF -J &quot;${CRD}_${ACT}_image&quot; &quot;make cloud_base&quot; || exit
  echo &quot;J: Build Action Region ...&quot;
  bsub $LSF -J &quot;${CRD}_${ACT}_image&quot; &quot;make cloud_action&quot; || exit
  echo &quot;J: Merge Static and Action Region ...&quot;
  echo &quot;ENABLE_CLOUD_BUILD_BITFILE=y&quot;                             &gt;&gt; .snap_config
  make -s oldconfig
  bsub $LSF -J &quot;${CRD}_${ACT}_image&quot; &quot;make cloud_merge&quot; || exit
fi


#==============================================================================================
# Checking generated binaries

# when using a parallel flash we have only 1 binary file
# when using a SPI8 flash we have 2 binary files to deal with

echo;echo &quot;****************************************************************************************&quot;
echo &quot;J: Checking generated $ACT binaries for $CRD... (`date`)&quot;
echo

#BINFILES contains binary name (In SPI : &quot;primary and secondary&quot; names)
BINFILES=`ls ${OCACCEL_ROOT}/hardware/build/Images/oc_[0-9]*.bin|grep -v FACTORY|head -n2`
BITFILES=`ls ${OCACCEL_ROOT}/hardware/build/Images/oc_[0-9]*.bit|grep -v FACTORY|head -n2`
    
  
if [ &quot;$BINFILES&quot; == &quot;&quot; ]; then echo &quot;  --&gt; cannot find binary files&quot;;exit 1
fi

COUNT_IMAGE=0
unset IMAGE
for  f in $BINFILES; do                   
  size=`ls -al $f | awk &apos;{print $5}&apos;`
  echo &quot;binfile=$f&quot;
  echo &quot;   -&gt; size=$size&quot;
  (( size &lt; 100000 )) &amp;&amp; die 1 &quot;  --&gt; image $f is too small $size to burn&quot;
 
  IMAGE[$COUNT_IMAGE]=&quot;/home/${HWUser}/images/${CRD}/${ACT}/&quot;`basename $f` 
  COUNT_IMAGE=`expr $COUNT_IMAGE + 1`
done


#==============================================================================================
# Checking if we can test the generated binaries on POWER Hardware (checking NO_TEST_CARDS list)

case ${TEST_ON_HW} in

  true )
    echo;echo &quot;****************************************************************************************&quot;
    echo &quot;J: Checking if we can test the generated binaries on POWER Hardware (test_on_hw=${TEST_ON_HW} for card=${CRD})&quot;
    echo
    TestCardAllowed=1
    for i in ${NO_TEST_CARDS[@]}
    do
      if [ &quot;$CRD&quot; == &quot;$i&quot; ];then TestCardAllowed=0;fi
    done

    if [ $TestCardAllowed -eq 0 ]
    then
      echo &quot;  -&gt; No test CARD $CRD available...&quot;
      LinkDir=${RootSaveDir}/${CRD}/${CRD}_test_bypassed
      SRCFILES=&quot;$BINFILES $BITFILES&quot;
      CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
      echo &quot;  -&gt; EXITING !&quot;
      exit 0
    else
      echo &quot;  -&gt; OK&quot;
    fi

#  AC 2020 May 20, hdl_example should work now
#    if [[ &quot;$ACT&quot; =~ &quot;hdl_example&quot; ]]; then
#      echo &quot;  -&gt; OpenCAPI hdl_example HW tests scripts not working...&quot;
#      LinkDir=${RootSaveDir}/${CRD}/${CRD}_test_bypassed
#      SRCFILES=&quot;$BINFILES $BITFILES&quot;
#      CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
#      echo &quot;  -&gt; EXITING !&quot;
#      exit 0
#    fi
  ;;
  
  false )
    echo;echo &quot;****************************************************************************************&quot;
    echo &quot;J: No test on POWER Hardware requested (test_on_hw=${TEST_ON_HW} for card=${CRD})&quot; 
    echo
    LinkDir=${RootSaveDir}/${CRD}/${CRD}_no_test_requested
    SRCFILES=&quot;$BINFILES $BITFILES&quot;
    CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
    exit 0
  ;;

esac


#==============================================================================================
#==============================================================================================
#==============================================================================================


#==============================================================================================
# Testing the generated binaries on POWER Hardware
# (if $TEST_ON_HW==true and $CRD NOT into $NO_TEST_CARDS[*])

# Set unique target directory such that parallel builds do not disturb each other.
# Well, we might to clean up those from time to time ...

TARGET_DIR=&quot;${JOB_NAME}-${BUILD_NUMBER}-${GIT_BRANCH}&quot;
export TARGET_DIR=`echo $TARGET_DIR | sed -e &apos;s/[=,\/]/-/g&apos;`
echo &quot;TARGET_DIR=${TARGET_DIR}&quot;
echo &quot;Current Dir is &quot; `pwd`
echo &quot;  -&gt; JOB_NAME:     ${JOB_NAME}&quot;
echo &quot;  -&gt; IMAGE(S):     ${IMAGE[*]}&quot;
echo &quot;  -&gt; CARD_TO_TEST: ${CRD}[$cardid]&quot;
echo &quot;  -&gt; ACTION:       ${ACT}&quot;
echo &quot;  -&gt; GIT_Branch:   ${GIT_BRANCH}&quot;
echo &quot;  -&gt; GIT_Commit:   ${GIT_COMMIT}&quot;

echo;echo &quot;***************************************************************************************&quot;
echo &quot;J: Checking TestBoxes reachability (test_on_hw=${TEST_ON_HW} for card=${CRD})&quot;
echo
echo &quot;  -&gt; testboxes now = ${TESTBOXES[@]}&quot;
echo

for box in &quot;${TESTBOXES[@]}&quot;;do
  echo &quot;----------------------------------------------------&quot;
  # connecTimeout=X just gives back after X seconds if system is not answering instead of freezing the job
  if [[ ${mopBoxes[*]} =~ $box ]]
  then
    # $box is a Montpellier server
    echo -e &quot;MOP   : $box -&gt; \c&quot;
    RC=0;ssh -o connectTimeout=5 ${HWUser}@$box ping localhost -c1 &gt;/dev/null 2&gt;&amp;1 || RC=$?
  else
    # $box is an Austin server
    echo -e &quot;AUSTIN: $box -&gt; \c&quot;
    RC=0;ssh -o connectTimeout=5 ${HWUser}@$box ping localhost -c1 &gt;/dev/null 2&gt;&amp;1 || RC=$?
  fi

if [ $RC -eq 0 ]; then : 
    echo &quot;OK&quot;
  else
    echo &quot;FAILED !&quot;
    for i in &quot;${TESTBOXES[@]}&quot;; do [[ $i != $box ]] &amp;&amp; new+=($i);done   # generate new test array without unreachable box
    unset TESTBOXES;TESTBOXES=(&quot;${new[@]}&quot;);unset new                   # reassign to original array name
    echo &quot;$box not reachable =&gt; removed from testing&quot;
    echo &quot;testboxes remaining = ${TESTBOXES[@]}&quot;
    if [[ &quot;${TESTBOXES[@]}&quot; == &quot;&quot; ]];then echo &quot;no test machines available anymore&quot;;exit 1;fi
  fi
done # for box

echo;echo &quot;----------------------------------------------------&quot;
echo &quot;testboxes now = ${TESTBOXES[@]}&quot;

function finish # define function to unlock in case of error, executed after registering with &quot;trap finish EXIT&quot;
  {
  echo;echo &quot;***************************************************************************************&quot;
  echo &quot;J: FINISH function&quot;
  echo &quot;RC=$?&quot;
  echo;echo &quot;  -&gt; unlocking ${LOCK}&quot;
  UNLOCK_RC=0;ssh ${HWUser}@$box rmdir ${LOCK} || UNLOCK_RC=$?
  echo &quot;box=$box lock=$LOCK unlock RC=$UNLOCK_RC (`date`)&quot;
  echo;echo &quot;  -&gt; cleaning ${box}@$TARGET_DIR&quot;
  CLEAN_RC=0;ssh -T ${HWUser}@$box rm -rf ${TARGET_DIR} || CLEAN_RC=$?
  echo &quot;box=$box clean target_dir=$TARGET_DIR RC=$CLEAN_RC (`date`)&quot;
  echo;echo &quot;  -&gt; EXITING !&quot;
  }


maxloop=60
echo;echo &quot;***************************************************************************************&quot;
echo &quot;J: Searching (max $maxloop min) for free card=$CRD into ( ${TESTBOXES[@]} ) (`date`)&quot;

FindCardTool=&quot;oc_find_card&quot;

for loop in `seq 1 $maxloop`;do

  echo;echo &quot;*************************************************&quot;
  echo &quot;J: LOOP $loop/$maxloop (`date`)&quot;
  
  global_found=0

  for box in &quot;${TESTBOXES[@]}&quot;;do

    echo;echo &quot;-------------------------------------------------&quot;
    echo &quot;$box&quot;

  # AC: Dirty invalidating user check
  
      if [ &quot;$CHECKUSER&quot; == &quot;true&quot; ]; then
           nusers=`ssh ${HWUser}@${box} who|grep -v root|grep -v ${HWUser}|wc -l`
      else 
           nusers=0
      fi
      
    #nusers=`ssh ${HWUser}@${box} who|grep -v root|grep -v ${HWUser}|wc -l`

    find_card=$FindCardTool.${GIT_COMMIT}.`date +%H%M%S`.`basename $BINFILES`

    echo  &quot;  --&gt; Copying the tool $FindCardTool ($find_card) to $box:/home/${HWUser}&quot;
    RC=0;scp ./software/tools/$FindCardTool ${HWUser}@$box:/home/${HWUser}/$find_card ; RC=$?
    if [ $RC -gt 0 ];then
      echo &quot;     -&gt; copy $find_card to $box FAILED, continuing anyway...&quot;;
    fi
    
    echo -e &quot;  --&gt; Using specific $FindCardTool, looking for $CRD inside ${box}: \c&quot;
    echo &quot;&quot;
    #echo &quot;Oc_find_card version is :&quot;;ssh -ttq ${HWUser}@${box} /home/${HWUser}/$find_card -V &gt; /dev/null 2&gt;&amp;1
    # Previous line doesn&apos;t provide version, and follwing generates errors, but at least we can check the version
    echo &quot;Oc_find_card version is :&quot;;ssh -ttq ${HWUser}@${box} /home/${HWUser}/$find_card -V
    
    #found=0;ssh -ttq ${HWUser}@${box} /home/${HWUser}/$find_card -A ${CRD} &gt; /dev/null 2&gt;&amp;1 ||found=$?
    found=0;ssh -ttq ${HWUser}@${box} /home/${HWUser}/$find_card -A ${CRD} &gt; /dev/null 2&gt;&amp;1 ||found=$?
    # ($find_card gives the number of found cards inside $?)
    # we use $find_card without the -v option. Be careful that any modification of oc_find_card report affects this step
    # make sure oc_find_card only report the cards numbers.
  
    if [ $found -ne 0 ];then
      echo -e &quot;OK: $found CARD(S) FOUND &quot;
      global_found=$((global_found+found))
      cards=`ssh -ttq ${HWUser}@${box} &quot;/home/${HWUser}/$find_card -A ${CRD} 2&gt;/dev/null&quot; | head -n1`   
      echo &quot;(card-IDs= $cards)&quot;
      # (head is needed because if more than 1 card, $find_card returns something like &quot;0 0&quot; and second line with &quot;Total 2 cards detected&quot;)
    else
      echo &quot;FAILED: NO CARD FOUND&quot;
      unset cards
    fi

    echo &quot;  --&gt; Removing the tool $FindCardTool ($find_card) from $box&quot;
    SSH_RC=0;ssh -ttq ${HWUser}@${box} rm /home/${HWUser}/$find_card || SSH_RC=$?
    if [ $SSH_RC -gt 0 ];then
      echo &quot;    -&gt; Delete $find_card to $box FAILED, continuing anyway...&quot;;
    fi

	echo;echo &quot;J: loop=$loop box=$box nusers=$nusers card=$CRD $FindCardTool found=$found (`date`)&quot;
    echo

    hours=`date +%H`

    case $found:$nusers in

      #------------------------------------
      # no card available =&gt; try other box
      0:*)
        for i in &quot;${TESTBOXES[@]}&quot;; do [[ $i != $box ]] &amp;&amp; new+=($i);done   # generate new test array without this bow with no card
        unset TESTBOXES;TESTBOXES=(&quot;${new[@]}&quot;);unset new                   # reassign to original array name
        echo &quot;  --&gt; No $CRD card available in $box =&gt; removed from Boxes testing list, remaining list= ${TESTBOXES[@]}&quot;        
        echo &quot;  --&gt; Trying next box / loop...&quot;        
      ;;

      #------------------------------------
      # card available &amp; no user =&gt; now lock &amp; test
      [1234]:0)
		for cardid in $cards;do
      	  LOCK=&quot;jenkins_lock_card$cardid&quot;
		  RC=0;ssh ${HWUser}@$box &quot;mkdir ${LOCK} 2&gt;/dev/null&quot;||RC=$?
		  if [ $RC == &quot;0&quot; ]; then :
		    echo &quot;  --&gt; box=$box lock=$LOCK lock RC=$RC (`date`)&quot;; 
		    trap finish EXIT  # register finish/unlock function, after lock is set
		    break 3 # found card and no user =&gt; going out of $box for-loop and $loop for-loop
	      else 
		    echo &quot;  --&gt; box=$box lock=$LOCK already locked, try next card&quot;
		  fi    
		done
      ;;

      #------------------------------------
      # found something else than 1,2,3 or 4 cards =&gt; meaning BAD $found return code
      *:0)      
        echo &quot;  --&gt; unknown found_RC=$found from $FindCardTool=$cards. EXITING...&quot;
        exit 100
      ;;

      #------------------------------------
      # card available but user(s) connected...
      *)      
      	if (( 9&lt;=hours &amp;&amp; hours&lt;=19 ));then
          # It is day time =&gt; priority to interactive users
      	  echo &quot;  --&gt; $CRD card found but day time (hours=$hours) and users connected (nusers=$nusers), trying next box / loop...&quot;

        else
          # It is night =&gt; running on $box even if there are connected users
          ssh ${HWUser}@${box} who|grep -v root|grep -v ${HWUser}
      	  echo &quot;  --&gt; hours=$hours (night), nusers=$nusers, now lock &amp; notify &amp; test&quot;
		  for cardid in $cards;do
      	    LOCK=&quot;jenkins_lock_card$cardid&quot;
		    RC=0;ssh ${HWUser}@$box &quot;mkdir ${LOCK} 2&gt;/dev/null&quot;||RC=$?
		    if [ $RC == &quot;0&quot; ]; then :
	  	      echo &quot;  --&gt; box=$box lock=$LOCK lock RC=$RC (`date`)&quot;; 
	   	      trap finish EXIT  # register finish/unlock function, after lock is set
              ssh ${HWUser}@$box wall &quot;WARNING: JENKINS OPENCAPI TEST STARTING NOW on FPGA CARD=$CRD ID=$cards&quot;
		      break 3 # found card and it is the night =&gt; going out of $box for-loop and $loop for-loop
			else 
			  echo &quot;  --&gt; box=$box lock=$LOCK already locked, try next card&quot;
			fi    
          done
        fi
      ;;
      
    esac

  if [[ $box == ${TESTBOXES[*]:(-1)} ]] &amp;&amp; [[ $global_found -gt 0 ]]; then
    echo &quot;J: $box was the last system to test. We globally found $global_found $CRD card(s) but user(s) were connected&quot;
    echo &quot;   Waiting for 60s and go to next loop...&quot;
    sleep 60
  fi

  done # for box
  
done #for loop


if [ $loop -eq $maxloop ];then
  echo;echo &quot;***************************************************************************************&quot;
  echo &quot;J: No card $CRD available with TESTBOXES= ${TESTBOXES[*]}&quot;
  echo
  
  LinkDir=${RootSaveDir}/${CRD}/${CRD}_not_available
  SRCFILES=&quot;$BINFILES $BITFILES&quot;
  CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
  echo &quot;  -&gt; EXITING !&quot;
  exit 100
fi

#------------------------------------------------------------------------------------------------------------------------------
# Preparing and running HW test

echo;echo &quot;***************************************************************************************&quot;
echo &quot; running test --&gt; $box&quot;  | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos;
echo &quot;***************************************************************************************&quot;

echo;echo &quot;***************************************************************************************&quot;
echo &quot;J: Preparing $CRD card image(s) test onto $box system&quot;
echo
echo -e &quot;  -&gt; Power OS release: \c&quot;; ssh ${HWUser}@${box} &quot;grep PRETTY_NAME /etc/os-release | cut -d= -f2&quot;
echo
ssh ${HWUser}@${box} &quot;echo ------ START of JOB on $box ----&gt;&gt; jenkins.log&quot;
ssh ${HWUser}@${box} &quot;date                                 &gt;&gt; jenkins.log&quot;
ssh ${HWUser}@${box} &quot;echo JOB_NAME  : $JOB_NAME           &gt;&gt; jenkins.log&quot;
ssh ${HWUser}@${box} &quot;echo Card      : $CRD[$cardid]       &gt;&gt; jenkins.log&quot;
ssh ${HWUser}@${box} &quot;echo Image     : ${IMAGE[*]}              &gt;&gt; jenkins.log&quot;
ssh ${HWUser}@${box} &quot;echo Build No  : ${BUILD_NUMBER}     &gt;&gt; jenkins.log&quot;
ssh ${HWUser}@${box} &quot;echo Git Branch: ${GIT_BRANCH}       &gt;&gt; jenkins.log&quot;

trap finish EXIT  # register finish/unlock function, after lock is set

# Git clone oc-accel tools into $box:$[TARGET_DIR}

echo;echo &quot;---------------------------------------------------------------------------------------&quot;
echo &quot;  -&gt; Preparing oc-accel workspace by cloning ${GIT_URL} into ${box}:${TARGET_DIR} using branch= ${GIT_BRANCH}&quot;
RC=0; ssh ${HWUser}@${box} &quot;git clone ${GIT_URL} ${TARGET_DIR};cd ${TARGET_DIR};git checkout ${GIT_BRANCH}&quot; || RC=$?

if [ $RC -ne 0 ];then 
    echo &quot;  -&gt; git clone ${GIT_URL} ${TARGET_DIR} failed at ${box} =&gt; copying image to $SaveDir&quot;
    LinkDir=${RootSaveDir}/${CRD}/${CRD}_gitclone_error
    SRCFILES=&quot;$BINFILES $BITFILES&quot;
    CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
	echo &quot;  -&gt; EXITING !&quot;
	exit 100
fi

# Git clone oc-utils tools into $box:/home/$HWUser

echo;echo &quot;---------------------------------------------------------------------------------------&quot;
echo &quot;  -&gt; Git cloning oc-Utils tools into $box:/home/$HWUser...&quot;
echo &quot;  (oc-flash-script.sh used by command `echo $RUN | cut -d&apos; &apos; -f1` )&quot;
RC=0; ssh ${HWUser}@${box} &quot;rm -rf oc-utils &amp;&amp; git clone -b $OCUTILS_BRANCH $OCUTILS_URL oc-utils&quot; || RC=$?

if [ $RC -ne 0 ];then 
    echo &quot;  -&gt; git clone -b $OCUTILS_BRANCH $OCUTILS_URL oc-utils failed at ${box} =&gt; copying image to $SaveDir&quot;
    LinkDir=${RootSaveDir}/${CRD}/${CRD}_gitclone_error
    SRCFILES=&quot;$BINFILES $BITFILES&quot;
    CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
	echo &quot;  -&gt; EXITING !&quot;
	exit 100
fi

# Build the oc-utils software into $box:/home/$HWUser/capi-utils on the $box

echo;echo &quot;---------------------------------------------------------------------------------------&quot;
echo &quot;  -&gt; Building the oc-utils software on $box in /home/$HWUser/oc-utils...&quot;
echo &quot; oc-utils is compiled locally to prevent over-writing the server default config (/lib/oc-utils preserved)&quot;
ssh ${HWUser}@${box} make -C /home/$HWUser/oc-utils


# Copy image(s) to ${box}:/home/${HWUser}/images/${CRD}/${ACT}

echo &quot;  -&gt; Copying image(s) to ${box}:/home/${HWUser}/images/${CRD}/${ACT}&quot;
ssh $box mkdir -p /home/${HWUser}/images/${CRD}/${ACT}    # create subdirectory, if not avail yet

COUNT_IMAGE=0                         # Modification to support SPI dual files cases
unset IMAGE
for f in $BINFILES
do
  IMAGE[$COUNT_IMAGE]=&quot;/home/${HWUser}/images/${CRD}/${ACT}/&quot;`basename $f`
  echo &quot;      $f -&gt; ${box}:${IMAGE[$COUNT_IMAGE]}&quot;
  RSYNC_RC=0;rsync -tvh $f ${HWUser}@$box:${IMAGE[$COUNT_IMAGE]} ; RSYNC_RC=$?
  if [ $RSYNC_RC -ne 0 ];then 
    echo &quot;  -&gt; copy FAILURE&quot;;
    break # Failure =&gt; going out of the for-loop
  fi
  COUNT_IMAGE=`expr $COUNT_IMAGE + 1`
done

if [ $RSYNC_RC -ne 0 ]; then
  LinkDir=${RootSaveDir}/${CRD}/${CRD}_rsync_error
  SRCFILES=&quot;$BINFILES $BITFILES $FACTBINFILES $FACTBITFILES&quot;
  CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
  echo &quot;EXITING !&quot;
  exit 100
fi

# Build and Run HW test $RUN Command

echo;echo &quot;***************************************************************************************&quot;
echo &quot;J: Testing $CRD card image(s) with Power $box system&quot;
echo

# ssh fpga@${box} lsb_release -a

echo &quot;  -&gt; Preparing command ...&quot;
RUN=&quot;./actions/scripts/oc_jenkins.sh&quot;
if [ ! -f $RUN ];then 
  echo &quot;  -&gt; Shell Script $RUN not found =&gt; EXITING !&quot;
  exit 100
fi

RUN+=&quot; -D ${TARGET_DIR}&quot;

BinFilesList=( $BINFILES )
if [ ${#BinFilesList[@]} -gt 1 ]; then
  # More than 1 image file (like with AD9V3 which will have 2)
  SPI8=1
else
  # Only 1 image file
  SPI8=0
fi

echo &quot;     Card=$CRD and SPI8=$SPI8&quot;

# For debugging purpose, if not giving an IMAGE to next $RUN test command, the $RUN command would run the test with
# the already in-place image inside the FPGA, without trying to reset the FPGA &amp; flash the new image.
# So you just need to uncomment the following line (unset IMAGE) to do so (deleting any IMAGE reference)

#unset IMAGE

if [ ${#IMAGE[@]} -eq 0 ]; then
  # no IMAGE to test=&gt; $RUN will just test the image already inside the FPGA (no reset, no flash)
  RUN+=&quot; -A ${CRD}&quot;
else
  if [ $SPI8 -eq 0 ]; then RUN+=&quot; -F ${IMAGE} -A ${CRD} -C $cardid&quot;;fi
  if [ $SPI8 -eq 1 ]; then RUN+=&quot; -F ${IMAGE[0]} -f ${IMAGE[1]} -A ${CRD} -C $cardid&quot;;fi
fi

echo;echo &quot;  -&gt; RUN command= $RUN&quot;


echo;echo &quot;***************************************************************************************&quot;
echo &quot;J: Building the software and actions on $box in $TARGET_DIR ...&quot;
echo
echo &quot;  -&gt; make clean software actions&quot;
echo
RC=0;ssh ${HWUser}@$box make -C ${TARGET_DIR} clean software actions || RC=$?

if [ $RC -ne 0 ]; then
  echo;echo &quot;  -&gt; make clean software actions FAILED&quot;
  echo &quot;  -&gt; EXITING !&quot;
  exit 100
fi

echo;echo &quot;***************************************************************************************&quot;
echo &quot;J: Executing below OC-ACCEL Jenkins test on $box from ${TARGET_DIR} directory (`date`):&quot;
echo &quot;  -&gt; $SudoOrNotSudo ${RUN}&quot;
echo
echo &quot;Expected test is:         $ACT&quot;
  

RC_RUN=0;ssh -T ${HWUser}@${box} &lt;&lt; EOF || RC_RUN=$?
	export TERM=xterm
	cd ${TARGET_DIR}
    pwd
	set -f  # the set -f command disables file name generation (&quot;path name expansion&quot;), meaning &quot;*.zip&quot; stays &quot;*.zip&quot;
    $SudoOrNotSudo ${RUN}
EOF



#------------------------------------------------------------------------------------------------------------------------------
# After the run (TO DO: check if run fails)
# Knowing what the ACT should be, we check if the hardware contains this action

echo &quot;J: Expected action is:            $ACT&quot;
cd actions/$ACT/
loc_requested_action=$(grep -r &quot;define ACTION_TYPE&quot; *| awk &apos;{print $NF}&apos;)
echo &quot;J: Expected action ID is:         $loc_requested_action&quot;
cd -

echo &quot;J: searching for existing action on $box (`date`) for card ${CRD} on position (-C) $cardid&quot;

RC_ACT_CHECK=0
ssh -T ${HWUser}@${box} &lt;&lt; EOF || RC_ACT_CHECK=$?
	pwd
    cd ${TARGET_DIR}/
    source ./snap_path.sh
    pwd
	cd actions/$ACT/
    pwd
    echo &quot;Collecting actions:&quot;

	requested_action=\$(grep -r &quot;define ACTION_TYPE&quot; *| awk &apos;{print \$NF}&apos;)
	actual_action=0x\$(snap_peek -w32 0x0010 | awk &apos;{print \$NF}&apos;)
    
    r_action_int=\$(printf &apos;%x&apos; &quot;\${requested_action}&quot;)
    a_action_int=\$(printf &apos;%x&apos; &quot;\${actual_action}&quot;)

	echo &quot;requested_action=\$requested_action&quot;
    echo &quot;actual_action=   \$actual_action&quot;
    echo &quot;r_action_int=    \$r_action_int&quot;
    echo &quot;a_action_int=    \$a_action_int&quot;
            if [ \$r_action_int == 0 ]; then
            	echo &quot;Can&apos;t find requested action!&quot;
            	exit 1
            	if [ \$a_action_int == 0 ]; then
            	echo &quot;Can&apos;t find actual action!&quot;
            	exit 1
            	fi
        	fi
    if [ &quot;\${a_action_int}&quot; == &quot;\${r_action_int}&quot; ]; then
    	echo &quot;actions match&quot;;
        exit 0;
    else
    	echo &quot;actions do NOT match =&gt; KO!&quot;;
        exit 1;
    fi
EOF

#------------------------------------------------------------------------------------------------------------------------------
# CHECKING Return codes, to check tested action is the proper one

echo;echo &quot;***************************************************************************************&quot;
echo &quot;J: Checking Action Match return code (`date`)...&quot;
echo

  if [ $RC_ACT_CHECK -eq 0 ]; then
  	echo &quot;ACTION MATCH return code is good&quot;
  else
  	echo &quot;ACTION DO NOT MATCH ==&gt;&gt;&gt; we let the next cleaning step to occur&quot;
  fi



# Write short log only, Clean workspace
# Note: this lines in the log file and the lines above can be 
ssh ${HWUser}@${box} &quot;echo Exit: $JOB_NAME RC_RUN = $RC_RUN at:\       &gt;&gt; jenkins.log&quot;
ssh ${HWUser}@${box} &quot;date                                     &gt;&gt; jenkins.log&quot;
ssh ${HWUser}@${box} &quot;echo ----------- EXIT -------------------&gt;&gt; jenkins.log&quot;

echo;echo &quot;***************************************************************************************&quot;
echo &quot;J: Cleaning up ${box}:${TARGET_DIR} (`date`)&quot;
echo
RM_RC=0;ssh -T ${HWUser}@${box} rm -rf ${TARGET_DIR} || RM_RC=$?

if [ $RM_RC -eq 0 ]; then
  echo &quot;  -&gt; Cleaning operation: OK&quot;
else
  echo &quot;  -&gt; Cleaning operation: FAILED&quot;
fi
  
if [ $RC_RUN -eq 0 ] &amp;&amp; [ $RC_ACT_CHECK -eq 0 ]; then
  echo;echo &quot;***************************************************************************************&quot;
  echo &quot;J: Test SUCCEEDED: RC_RUN = $RC_RUN AND HARDWARE ACTION MATCH TEST CASE (`date`)&quot;
  
  echo &quot;  -&gt;  CARD $CRD Hardware test succeeded...&quot;  
  LinkDir=${RootSaveDir}/${CRD}/${CRD}_test_OK
  SRCFILES=&quot;$BINFILES $BITFILES&quot;
  CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
  
  

else
  echo;echo &quot;***************************************************************************************&quot;
  echo &quot;J: Test FAILED&quot;
  echo &quot;J: JOB RC_RUN = $RC_RUN&quot;
  if [ $RC_ACT_CHECK -eq 1 ]; then
  	echo &quot;J: HARDWARE ACTION DOES NOT MATCH ACTION FROM TEST CASE !!(`date`)&quot;
  fi
  echo &quot;  -&gt;  CARD $CRD Hardware test failed...&quot;
  LinkDir=${RootSaveDir}/${CRD}/${CRD}_test_failure
  SRCFILES=&quot;$BINFILES $BITFILES&quot;
  CopyToDir -c $CRD -f &quot;$SRCFILES&quot; -d $SaveDir -l $LinkDir -s &quot;$IMGServers&quot; -u $HWUser
  echo &quot;  -&gt; EXITING !&quot;
  exit 1
fi 
</command>
    </hudson.tasks.Shell>
  </builders>
  <publishers>
    <hudson.tasks.Mailer plugin="mailer@1.29">
      <recipients>fabrice_moyen@fr.ibm.com</recipients>
      <dontNotifyEveryUnstableBuild>false</dontNotifyEveryUnstableBuild>
      <sendToIndividuals>false</sendToIndividuals>
    </hudson.tasks.Mailer>
    <hudson.plugins.ws__cleanup.WsCleanup plugin="ws-cleanup@0.37">
      <patterns class="empty-list"/>
      <deleteDirs>false</deleteDirs>
      <skipWhenFailed>false</skipWhenFailed>
      <cleanWhenSuccess>true</cleanWhenSuccess>
      <cleanWhenUnstable>true</cleanWhenUnstable>
      <cleanWhenFailure>false</cleanWhenFailure>
      <cleanWhenNotBuilt>true</cleanWhenNotBuilt>
      <cleanWhenAborted>false</cleanWhenAborted>
      <notFailBuild>false</notFailBuild>
      <cleanupMatrixParent>false</cleanupMatrixParent>
      <externalDelete></externalDelete>
      <disableDeferredWipeout>false</disableDeferredWipeout>
    </hudson.plugins.ws__cleanup.WsCleanup>
  </publishers>
  <buildWrappers>
    <hudson.plugins.ws__cleanup.PreBuildCleanup plugin="ws-cleanup@0.37">
      <deleteDirs>false</deleteDirs>
      <cleanupParameter></cleanupParameter>
      <externalDelete></externalDelete>
      <disableDeferredWipeout>false</disableDeferredWipeout>
    </hudson.plugins.ws__cleanup.PreBuildCleanup>
    <org.jenkinsci.plugins.credentialsbinding.impl.SecretBuildWrapper plugin="credentials-binding@1.20">
      <bindings>
        <org.jenkinsci.plugins.credentialsbinding.impl.UsernamePasswordMultiBinding>
          <credentialsId>LSFUser</credentialsId>
          <usernameVariable>AFSUser</usernameVariable>
          <passwordVariable>AFSPass</passwordVariable>
        </org.jenkinsci.plugins.credentialsbinding.impl.UsernamePasswordMultiBinding>
      </bindings>
    </org.jenkinsci.plugins.credentialsbinding.impl.SecretBuildWrapper>
    <hudson.plugins.build__timeout.BuildTimeoutWrapper plugin="build-timeout@1.19">
      <strategy class="hudson.plugins.build_timeout.impl.NoActivityTimeOutStrategy">
        <timeoutSecondsString>14400</timeoutSecondsString>
      </strategy>
      <operationList>
        <hudson.plugins.build__timeout.operations.FailOperation/>
      </operationList>
    </hudson.plugins.build__timeout.BuildTimeoutWrapper>
    <hudson.plugins.timestamper.TimestamperBuildWrapper plugin="timestamper@1.10"/>
    <org.jenkinsci.plugins.buildnamesetter.BuildNameSetter plugin="build-name-setter@2.0.3">
      <template>#${BUILD_NUMBER} ${GIT_BRANCH} Vivado=${ENV,var=&quot;VIVADO_GLOBAL&quot;} HWTest=${ENV,var=&quot;TEST_ON_HW&quot;} NOHWCards= ${ENV,var=&quot;NO_TEST_CARDS&quot;}</template>
      <descriptionTemplate></descriptionTemplate>
      <runAtStart>true</runAtStart>
      <runAtEnd>true</runAtEnd>
    </org.jenkinsci.plugins.buildnamesetter.BuildNameSetter>
  </buildWrappers>
  <executionStrategy class="hudson.matrix.DefaultMatrixExecutionStrategyImpl">
    <runSequentially>false</runSequentially>
    <touchStoneCombinationFilter>ACT==&quot;test&quot; &amp;&amp; CRD_CL==&quot;OC-AD9V3_nCL&quot;</touchStoneCombinationFilter>
    <touchStoneResultCondition>
      <name>UNSTABLE</name>
      <ordinal>1</ordinal>
      <color>YELLOW</color>
      <completeBuild>true</completeBuild>
    </touchStoneResultCondition>
  </executionStrategy>
  <childCustomWorkspace>${BRANCH}/${COMBINATION}</childCustomWorkspace>
</matrix-project>